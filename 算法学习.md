## 采用欧几里得算法求两个数的公约数
```C
//递归方法
int RGcd(int m, int n)
{
	if (m == 0)
	{
		return n;
	}
	return RGcd(n % m, m);
}

int Gcm(int m, int n)
{
	if (m > n)	//确保m始终小于n
	{
		swap(m, n);
	}
	return RGcd(m, n);
}

//迭代算法
int Gcd(int m, int n)
{
	if (m == 0)
		return n;
	if (n == 0)
		return m;

	if (m > n)
		swap(m, n);

	while (m != 0)
	{
		int c = n % m;
		m = c;
		n = m;
	}
	return n;
}

//连续整数检测算法求最大公约数
int Gcd(int m, int n)
{
	if (m == 0)
		return n;
	if (n == 0)
		return m;

	int t = m < n ? m : n;

	while (m % t || n % t)
		t--;
	return t;
}
```

## 汉诺塔问题
```C
#include <stdio.h>
#include <isolation.h>

void move(char X, char Z);
void hanio(int n, char X, char Y, char Z);

void move(char X, char Z)
{
	printf("%c -> %c\n", X, Z);
}

void hanio(int n, char X, char Y, char Z)
{
	if (n == 1)
		move(X, Z);
	else
	{
		hanio(n - 1, X, Z, Y);
		move(X, Z);
		hanio(n - 1, Y, X, Z);
	}
}

int main(void)
{
	char A = 'X', B = 'Y', C = 'Z';

	hanio(3, A, B, C);

	system("pause");
	return 0;
}
```
[参考讲解](https://www.baidu.com/link?url=5NhaNYaJpwRvJ-QqvAZUPNQ0eyrTIoS-sD0L5NpFnyg7oRM_rEAvOhrT4KNVyBJIcek38zRvAtIa1ZCaxVT2ZK&wd=&eqid=85932adb00046a3a00000003584b7b26)

## 斐波那契数列
```C
long Fib(int n)
{
	//检查n为大于0的正整数
	//then
	if(n == 1 || n == 2)
		return 1;
	
	return Fib(n) = Fib(n-1) + Fib(n-2);
]
```
## 逆序输出正整数的各位数
```C
//递归方法
void PrintDigit(unsigned int n)
{
	printf("%d", n % 10);

	if (n >= 10)
	{
		PrintDigit(n / 10);
	}
}
```